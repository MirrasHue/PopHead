
// NOTE: This code is automatically generated by meta/entitiesParser.exe 

#include "pch.hpp"
#include "entitiesDebugger.hpp"
#include "Renderer/renderer.hpp"
#include "ECS/components.hpp"

extern bool debugWindowOpen;

namespace ph::system {

constexpr unsigned lookForSize = 255;
static char lookFor[lookForSize];
static bool highlightSelected = true;

static char* components[] = {
	"Health", "Damage", "Player", "Killable", "InPlayerGunAttackArea"
};
static bool selectedComponents[IM_ARRAYSIZE(components)];

static unsigned getCharCount(char* str, size_t size)
{
	for(unsigned charCount = 0; charCount < static_cast<unsigned>(size); ++charCount)
		if(str[charCount] == 0)
			return charCount;
	return static_cast<unsigned>(size);
}

void EntitiesDebugger::update(float dt)
{
	PH_PROFILE_FUNCTION();

	if(debugWindowOpen && ImGui::BeginTabItem("entities debugger"))
	{
		ImGui::BeginChild("entities", ImVec2(360, 0), true);
		ImGui::Checkbox("hightlight selected", &highlightSelected);

		if(ImGui::TreeNode("choose components"))
		{
			if(ImGui::ListBoxHeader("comListBox"))
			{	
				for(int i = 0; i < IM_ARRAYSIZE(components); ++i)			
				{
					ImGui::Selectable(components[i], selectedComponents + i);
				}
				ImGui::ListBoxFooter();
			}
			ImGui::TreePop();
		}

		ImGui::InputText("debug name", lookFor, lookForSize);

		unsigned lookForCharCount = getCharCount(lookFor, lookForSize);

		auto selectableEntity = [=](entt::entity entity)
		{
			bool displayThisEntity = true;
			char label[50];
			if(auto* debugName = mRegistry.try_get<component::DebugName>(entity))
			{
				char* name = debugName->name;
				unsigned nameCharCount = getCharCount(name, strlen(name));
				sprintf(label, "%u - %s", entity, name);
				if(lookForCharCount != 0 && lookFor[0] != ' ')
				{
					for(unsigned i = 0; i <= nameCharCount && i < lookForCharCount; ++i)
					{
						char nameChar = name[i];
						char lookForChar = lookFor[i]; 
						if(nameChar != lookForChar)
						{
							if(lookForChar > 96 && lookForChar < 123)
							{
								if(lookForChar - 32 != nameChar)
								{
									displayThisEntity = false;
									break;
								}
							}
							else
							{
								displayThisEntity = false;
								break;
							}
						}
					}
				}
			}
			else if(lookFor[0] == ' ')
			{
				sprintf(label, "%u", entity);
			}
			else
			{
				displayThisEntity = false;
			}

			if(displayThisEntity && ImGui::Selectable(label, mSelected == entity))
			{
				mSelected = entity;
			}
		};

		std::vector<entt::component> types;
		if(selectedComponents[0]) types.emplace_back(mRegistry.type<component::Health>());
		if(selectedComponents[1]) types.emplace_back(mRegistry.type<component::Damage>());
		if(selectedComponents[2]) types.emplace_back(mRegistry.type<component::Player>());
		if(selectedComponents[3]) types.emplace_back(mRegistry.type<component::Killable>());
		if(selectedComponents[4]) types.emplace_back(mRegistry.type<component::InPlayerGunAttackArea>());

		if(types.empty() || types.size() == IM_ARRAYSIZE(components))
		{
			mRegistry.each([=](auto entity)
			{
				selectableEntity(entity);
			});
		}
		else
		{
			mRegistry.runtime_view(types.cbegin(), types.cend()).each([=](auto entity)
			{
				selectableEntity(entity);
			});	
		}
		ImGui::EndChild();
		ImGui::SameLine();

		ImGui::BeginChild("components view");
		ImGui::Text("Components view:");

		if(mRegistry.valid(mSelected))
		{
			bool bodyValid = false;
			component::BodyRect body;	

			// HEADER ENDS

if(auto* c = mRegistry.try_get<component::BodyRect>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("BodyRect: %f, %f, %f, %f", c->x, c->y, c->w, c->h);
}
if(auto* c = mRegistry.try_get<component::Kinematics>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("Kinematics");
ImGui::Text("vel: %f, %f", c->vel.x, c->vel.y);
ImGui::Text("acceleration: %f, %f", c->acceleration.x, c->acceleration.y);
ImGui::Text("friction: %f", c->friction);
ImGui::Text("defaultFriction: %f", c->defaultFriction);
ImGui::Text("frictionLerpSpeed: %f", c->frictionLerpSpeed);
}
if(auto* c = mRegistry.try_get<component::CharacterSpeed>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("CharacterSpeed");
ImGui::Text("speed: %f", c->speed);
}
if(auto* c = mRegistry.try_get<component::StaticCollisionBody>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("StaticCollisionBody");
}
if(auto* c = mRegistry.try_get<component::MultiStaticCollisionBody>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("MultiStaticCollisionBody");
ImGui::Text("rects: std::vector view is not supported!");
ImGui::Text("sharedBounds: %f, %f, %f, %f", c->sharedBounds.x,  c->sharedBounds.y, c->sharedBounds.w, c->sharedBounds.h);
}
if(auto* c = mRegistry.try_get<component::KinematicCollisionBody>(mSelected)) 
{
ImGui::Separator();
ImGui::BulletText("KinematicCollisionBody");
ImGui::Text("mass: %f", c->mass);
if(c->staticallyMovedUp) ImGui::Text("staticallyMovedUp: true"); else ImGui::Text("staticallyMovedUp: false");
if(c->staticallyMovedDown) ImGui::Text("staticallyMovedDown: true"); else ImGui::Text("staticallyMovedDown: false");
if(c->staticallyMovedLeft) ImGui::Text("staticallyMovedLeft: true"); else ImGui::Text("staticallyMovedLeft: false");
if(c->staticallyMovedRight) ImGui::Text("staticallyMovedRight: true"); else ImGui::Text("staticallyMovedRight: false");
}


			// FOOTER STARTS

			if(highlightSelected && bodyValid)
			{
				Renderer::submitQuad(nullptr, nullptr, &sf::Color(255, 0, 0, 150), nullptr, body.pos, body.size,
									 10, 0.f, {}, ProjectionType::gameWorld, false);
			}
		}

		ImGui::EndChild();
		ImGui::EndTabItem();
	}
}

}
